<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    
    <!-- Imporant meta information to make the page as rigid as possible on mobiles, to avoid unintentional zooming on the page itself  -->
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Character Tutorial</title>
    
</head>
<body>
  
  <!-- The loading element overlays all else until the model is loaded, at which point we remove this element from the DOM -->  
<div class="loading" id="js-loader"><div class="loader"></div></div> 
  
<div class="wrapper">
<div id="controls">
  <button id="save_scene">Save position</button>
  <button id="load_scene">Load position</button>
</div>
    <!-- The canvas element is used to draw the 3D scene -->
<canvas id="c"></canvas>

</div>
</body>
</html>


<!-- <script src='./modeling.js'></script> -->
<script type="module">
  import {OrbitControls} from 'https://threejs.org/examples/jsm/controls/OrbitControls.js'
  import * as THREE from 'https://threejs.org/build/three.module.js'
  import { FBXLoader } from 'https://threejs.org/examples/jsm/loaders/FBXLoader.js';
  import {GUI} from 'https://threejs.org/examples/jsm/libs/dat.gui.module.js'
  import { GLTFExporter } from 'https://threejs.org/examples/jsm/exporters/GLTFExporter.js';


  (function () {
  // Set our main variables
  let scene,
    renderer,
    camera,
    controls,
    model,                              // Our character
    neck,                               // Reference to the neck bone in the skeleton
    waist,                               // Reference to the waist bone in the skeleton
    possibleAnims,                      // Animations found in our file
    mixer,                              // THREE.js animations mixer
    idle,                               // Idle, the default state our character returns to
    clock = new THREE.Clock(),          // Used for anims, which run to a clock instead of frame rate 
    currentlyAnimating = false,         // Used to check whether characters neck is being used in another anim
    raycaster = new THREE.Raycaster(),  // Used to detect the click on our character
    loaderAnim = document.getElementById('js-loader'),
    gui = new GUI(),
    xbones =[],
    ybones =[],
    uiSetup = false,
    xbotLoaded = false,
    ybotLoaded = false,
    irrelevantBoneNames = ["mixamorigHeadTop_End", "mixamorigLeftEye", "mixamorigRightEye", "mixamorigLeftToe_End", "mixamorigRightToe_End"];

  init();

  function init() {
    const MODEL_PATH = 'xbot.fbx';
    const MODEL2_PATH = 'ybot.fbx';
    const canvas = document.querySelector('#c');
    const backgroundColor = 0xfff1f1;

    // Init the scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(backgroundColor);

    // Init the renderer
    renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.shadowMap.enabled = true;
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Add a camera
    camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 300
    camera.position.x = 100;
    camera.position.y = 75;

    var loader = new FBXLoader();

    function loadBotModel(x_coords) {
      return function(model){
        
        let fileAnimations = model.animations;
        mixer = new THREE.AnimationMixer(model);
        var action = mixer.clipAction(model.animations[0]);
        // action.play();

        model.traverse(o => {

          if (o.isMesh) {
            o.castShadow = true;
            o.receiveShadow = true;
            // o.material = stacy_mtl;
          }
          if (o.isBone && o.userData.transformData && !irrelevantBoneNames.includes(o.name)){
            if (x_coords > 0 ){
         
              ybones.push(o)
            }
            else{
              
              xbones.push(o)
            }
          }
          
          // Reference the neck and waist bones
          // if (o.isBone && o.name === 'mixamorigNeck') {
          //   neck = o;
          // }
          // if (o.isBone && o.name === 'mixamorigSpine') {
          //   waist = o;
          // }
        });

        model.scale.set(1, 1, 1);
        model.position.x = x_coords;

        scene.add(model);

        loaderAnim.remove();
        if(x_coords > 0){
          ybotLoaded = true;
        } else {
          xbotLoaded = true;
        }
      }
    }

    loader.load(
      MODEL_PATH,
      loadBotModel(0),
      undefined, // We don't need this function
      function (error) {
        console.error(error);
      }
    );

    loader.load(
      MODEL2_PATH,
      loadBotModel(200),
      undefined, // We don't need this function
      function (error) {
        console.error(error);
      }
    );

    // Add lights
    let hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.61);
    hemiLight.position.set(100, 50, 0);
    // Add hemisphere light to scene
    scene.add(hemiLight);

    let d = 8.25;
    let dirLight = new THREE.DirectionalLight(0xffffff, 0.54);
    dirLight.position.set(-8, 12, 8);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize = new THREE.Vector2(1024, 1024);
    dirLight.shadow.camera.near = 0.1;
    dirLight.shadow.camera.far = 1500;
    dirLight.shadow.camera.left = d * -1;
    dirLight.shadow.camera.right = d;
    dirLight.shadow.camera.top = d;
    dirLight.shadow.camera.bottom = d * -1;
    // Add directional Light to scene
    scene.add(dirLight);

    // ground
    var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
    mesh.rotation.x = - Math.PI / 2;
    mesh.receiveShadow = true;
    scene.add( mesh );

    var grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
    grid.material.opacity = 0.2;
    grid.material.transparent = true;
    scene.add( grid );

    var grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
    grid.material.opacity = 0.2;
    grid.material.transparent = true;
    scene.add( grid );
        
    //Add orbit controls to camera
    controls = new OrbitControls( camera, renderer.domElement );
    controls.target.set( 100, 75, 0 );
    controls.update();

    document.getElementById( 'save_scene' ).addEventListener( 'click', function () {
      exportGLTF( scene );
    } );

    document.getElementById( 'load_scene' ).addEventListener( 'click', function () {

      importGLTF();

    } );

  }

  function exportGLTF(scene){
    var gltfExporter = new GLTFExporter();
    var options = {};
    gltfExporter.parse(scene, function(result){
      var output = JSON.stringify( result, null, 2 );
      console.log( output );
      saveString( output, 'scene.gltf' );
    }, options);
  }

  function importGLTF(){

  }
  var link = document.createElement( 'a' );
  link.style.display = 'none';
  document.body.appendChild( link ); // Firefox workaround, see #6594

  function save( blob, filename ) {

    link.href = URL.createObjectURL( blob );
    link.download = filename;
    link.click();

  // URL.revokeObjectURL( url ); breaks Firefox...

  }

function saveString( text, filename ) {

  save( new Blob( [ text ], { type: 'text/plain' } ), filename );

}

  function addBoneUi(container, bones){
    var movement = container.addFolder("Move model");
    movement.add(bones[0].position, 'x', -200 + bones[0].position.x, 200 + bones[0].position.x);
    movement.add(bones[0].position, 'y', -100 + bones[0].position.y, 100 + bones[0].position.y);
    movement.add(bones[0].position, 'z', -200 + bones[0].position.z, 200 + bones[0].position.z);
    
    movement.__controllers[ 0 ].name( "Position.x" );
    movement.__controllers[ 1 ].name( "Position.y" );
    movement.__controllers[ 2 ].name( "Position.z" );
    movement.add( bones[0].rotation, 'x', - Math.PI * 0.5, Math.PI * 0.5 );
    movement.add( bones[0].rotation, 'y', - Math.PI * 0.5, Math.PI * 0.5 );
    movement.add( bones[0].rotation, 'z', - Math.PI * 0.5, Math.PI * 0.5 );

    movement.__controllers[ 3 ].name( "rotation.x" );
    movement.__controllers[ 4 ].name( "rotation.y" );
    movement.__controllers[ 5 ].name( "rotation.z" );

    var trunkFolder = container.addFolder("Trunk");
    var armFolder = container.addFolder("Arms");
    var legFolder = container.addFolder("Legs");
    var handFolder = armFolder.addFolder("Hands");


    //using 1 index, since hips are special
    for ( var i = 1; i < bones.length; i ++ ) {

      var bone = bones[ i ];
      var groupFolder;
      if(bone.name.includes("Arm") || bone.name.includes("Shoulder")){
        groupFolder = armFolder;
      } else if(bone.name.includes("Hand")){
        groupFolder = handFolder;
      } else if(bone.name.includes("Leg") || bone.name.includes("Foot")|| bone.name.includes("Toe")){
        groupFolder = legFolder;
      } else {
        groupFolder = trunkFolder;
      }
      
      var folder = groupFolder.addFolder( bone.name.substring(9) );

      folder.add( bone.rotation, 'x', - Math.PI * 0.5, Math.PI * 0.5 );
      folder.add( bone.rotation, 'y', - Math.PI * 0.5, Math.PI * 0.5 );
      folder.add( bone.rotation, 'z', - Math.PI * 0.5, Math.PI * 0.5 );

      folder.__controllers[ 0 ].name( "rotation.x" );
      folder.__controllers[ 1 ].name( "rotation.y" );
      folder.__controllers[ 2 ].name( "rotation.z" );



    }
  }  

  function setupDatGui() {
    if(!uiSetup && xbotLoaded && ybotLoaded){
      uiSetup = true;
      addBoneUi(gui.addFolder( "Blue Bot" ), ybones);
      addBoneUi(gui.addFolder( "Red Bot" ), xbones);

    }
  }


  function update() {
    if (mixer) {
      mixer.update(clock.getDelta());
    }

    renderer.render(scene, camera);
    requestAnimationFrame(update);
    setupDatGui();
  }

  window.addEventListener( 'resize', onWindowResize, false );
  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );
  }

  update();
  onWindowResize();


  
  // window.addEventListener('click', e => raycast(e));
  // window.addEventListener('touchend', e => raycast(e, true));

  function raycast(e, touch = false) {
    var mouse = {};
    if (touch) {
      mouse.x = 2 * (e.changedTouches[0].clientX / window.innerWidth) - 1;
      mouse.y = 1 - 2 * (e.changedTouches[0].clientY / window.innerHeight);
    } else {
      mouse.x = 2 * (e.clientX / window.innerWidth) - 1;
      mouse.y = 1 - 2 * (e.clientY / window.innerHeight);
    }
    // update the picking ray with the camera and mouse position
    raycaster.setFromCamera(mouse, camera);

    // calculate objects intersecting the picking ray
    var intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects[0]) {
      var object = intersects[0].object;

      console.error(object.name);
    
    }
  }
  // Get a random animation, and play it 
  function playOnClick() {
    let anim = Math.floor(Math.random() * possibleAnims.length) + 0;
    playModifierAnimation(idle, 0.25, possibleAnims[anim], 0.25);
  }

  function playModifierAnimation(from, fSpeed, to, tSpeed) {
    to.setLoop(THREE.LoopOnce);
    to.reset();
    to.play();
    from.crossFadeTo(to, fSpeed, true);
    setTimeout(function() {
      from.enabled = true;
      to.crossFadeTo(from, tSpeed, true);
      currentlyAnimating = false;
    }, to._clip.duration * 1000 - ((tSpeed + fSpeed) * 1000));
  }

  // document.addEventListener('mousemove', function (e) {
  //   var mousecoords = getMousePos(e);
  //   if (neck && waist) {

  //     moveJoint(mousecoords, neck, 50);
  //     moveJoint(mousecoords, waist, 30);
  //   }
  // });

  function getMousePos(e) {
    return { x: e.clientX, y: e.clientY };
  }

  function moveJoint(mouse, joint, degreeLimit) {
    let degrees = getMouseDegrees(mouse.x, mouse.y, degreeLimit);
    joint.rotation.y = THREE.Math.degToRad(degrees.x);
    joint.rotation.x = THREE.Math.degToRad(degrees.y);
    console.log(joint.rotation.x);
  }

  function getMouseDegrees(x, y, degreeLimit) {
    let dx = 0,
      dy = 0,
      xdiff,
      xPercentage,
      ydiff,
      yPercentage;

    let w = { x: window.innerWidth, y: window.innerHeight };

    // Left (Rotates neck left between 0 and -degreeLimit)
    // 1. If cursor is in the left half of screen
    if (x <= w.x / 2) {
      // 2. Get the difference between middle of screen and cursor position
      xdiff = w.x / 2 - x;
      // 3. Find the percentage of that difference (percentage toward edge of screen)
      xPercentage = (xdiff / (w.x / 2)) * 100;
      // 4. Convert that to a percentage of the maximum rotation we allow for the neck
      dx = ((degreeLimit * xPercentage) / 100) * -1;
    }

    // Right (Rotates neck right between 0 and degreeLimit)
    if (x >= w.x / 2) {
      xdiff = x - w.x / 2;
      xPercentage = (xdiff / (w.x / 2)) * 100;
      dx = (degreeLimit * xPercentage) / 100;
    }
    // Up (Rotates neck up between 0 and -degreeLimit)
    if (y <= w.y / 2) {
      ydiff = w.y / 2 - y;
      yPercentage = (ydiff / (w.y / 2)) * 100;
      // Note that I cut degreeLimit in half when she looks up
      dy = (((degreeLimit * 0.5) * yPercentage) / 100) * -1;
    }
    // Down (Rotates neck down between 0 and degreeLimit)
    if (y >= w.y / 2) {
      ydiff = y - w.y / 2;
      yPercentage = (ydiff / (w.y / 2)) * 100;
      dy = (degreeLimit * yPercentage) / 100;
    }
    return { x: dx, y: dy };
  }

})();
</script>